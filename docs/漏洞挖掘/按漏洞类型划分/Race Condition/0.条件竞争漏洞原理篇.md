## 0x01 什么是条件竞争

当两个或多个线程可以访问共享数据时，并同时尝试更改它，会产生条件竞争问题。 由于线程调度算法可以随时在线之间交换，因此您不知道线程将尝试访问共享数据的顺序。 因此，数据变化的结果取决于线程调度算法，即，两个线程都是“Racing”访问/更改数据。

条件竞争需要如下的**条件**：

- 并发，即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。
- 共享对象，即多个并发流会访问同一对象。**常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。**此外，我们称访问共享对象的代码为**临界区**。在正常写代码时，这部分应该加锁。
- 改变对象，即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。

由于在并发时，执行流的不确定性很大，条件竞争相对**难察觉**，并且在**复现和调试方面会比较困难**。这给修复条件竞争也带来了不小的困难。

条件竞争造成的影响也是多样的，轻则程序异常执行，重则程序崩溃。如果条件竞争漏洞被攻击者利用的话，很有可能会使得攻击者获得相应系统的特权。

仔细思考一下条件竞争为什么可能会发生呢？以下面的为具体的例子

- 程序首先执行了 action1，然后执行了 action2。其中 action 可能是应用级别的，也可能是操作系统级别的。正常来说，我们希望程序在执行 action2 时，action1 所产生的条件仍然是满足的。
- 但是由于程序的并发性，攻击者很有可能可以在 action2 执行之前的这个短暂的时间窗口中破坏 action1 所产生的条件。这时候攻击者的操作与 action2 产生了条件竞争，所以可能会影响程序的执行效果。

![img](0.%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E7%AF%87.assets/time_interval.png)