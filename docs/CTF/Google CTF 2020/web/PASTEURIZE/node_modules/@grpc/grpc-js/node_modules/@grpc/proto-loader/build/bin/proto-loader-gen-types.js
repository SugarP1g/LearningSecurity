#!/usr/bin/env node
"use strict";
/**
 * @license
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Protobuf = require("protobufjs");
const yargs = require("yargs");
const camelCase = require("lodash.camelcase");
const util_1 = require("../src/util");
class TextFormatter {
    constructor() {
        this.indentText = '  ';
        this.indentValue = 0;
        this.textParts = [];
    }
    indent() {
        this.indentValue += 1;
    }
    unindent() {
        this.indentValue -= 1;
    }
    writeLine(line) {
        for (let i = 0; i < this.indentValue; i += 1) {
            this.textParts.push(this.indentText);
        }
        this.textParts.push(line);
        this.textParts.push('\n');
    }
    getFullText() {
        return this.textParts.join('');
    }
}
// GENERATOR UTILITY FUNCTIONS
function compareName(x, y) {
    if (x.name < y.name) {
        return -1;
    }
    else if (x.name > y.name) {
        return 1;
    }
    else {
        return 0;
    }
}
function isNamespaceBase(obj) {
    return Array.isArray(obj.nestedArray);
}
function stripLeadingPeriod(name) {
    return name.startsWith('.') ? name.substring(1) : name;
}
function getImportPath(to) {
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/');
}
function getPath(to) {
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/') + '.ts';
}
function getRelativeImportPath(from, to) {
    const depth = stripLeadingPeriod(from.fullName).split('.').length - 1;
    let path = '';
    for (let i = 0; i < depth; i++) {
        path += '../';
    }
    return path + getImportPath(to);
}
function getTypeInterfaceName(type) {
    return type.fullName.replace(/\./g, '_');
}
function getImportLine(dependency, from) {
    const filePath = from === undefined ? './' + getImportPath(dependency) : getRelativeImportPath(from, dependency);
    const typeInterfaceName = getTypeInterfaceName(dependency);
    const importedTypes = dependency instanceof Protobuf.Type ? `${dependency.name} as ${typeInterfaceName}, ${dependency.name}__Output as ${typeInterfaceName}__Output` : `${dependency.name} as ${typeInterfaceName}`;
    return `import { ${importedTypes} } from '${filePath}';`;
}
function getChildMessagesAndEnums(namespace) {
    const messageList = [];
    for (const nested of namespace.nestedArray) {
        if (nested instanceof Protobuf.Type || nested instanceof Protobuf.Enum) {
            messageList.push(nested);
        }
        if (isNamespaceBase(nested)) {
            messageList.push(...getChildMessagesAndEnums(nested));
        }
    }
    return messageList;
}
function formatComment(formatter, comment) {
    if (!comment) {
        return;
    }
    formatter.writeLine('/**');
    for (const line of comment.split('\n')) {
        formatter.writeLine(` * ${line.replace(/\*\//g, '* /')}`);
    }
    formatter.writeLine(' */');
}
// GENERATOR FUNCTIONS
function generatePermissiveMessageInterface(formatter, messageType, options, nameOverride) {
    if (options.includeComments) {
        formatComment(formatter, messageType.comment);
    }
    if (messageType.fullName === '.google.protobuf.Any') {
        /* This describes the behavior of the Protobuf.js Any wrapper fromObject
         * replacement function */
        formatter.writeLine('export type Any = AnyExtension | {');
        formatter.writeLine('  type_url: string;');
        formatter.writeLine('  value: Buffer | Uint8Array | string;');
        formatter.writeLine('}');
        return;
    }
    formatter.writeLine(`export interface ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name} {`);
    formatter.indent();
    for (const field of messageType.fieldsArray) {
        const repeatedString = field.repeated ? '[]' : '';
        let type;
        switch (field.type) {
            case 'double':
            case 'float':
                type = 'number | string';
                break;
            case 'int32':
            case 'uint32':
            case 'sint32':
            case 'fixed32':
            case 'sfixed32':
                type = 'number';
                break;
            case 'int64':
            case 'uint64':
            case 'sint64':
            case 'fixed64':
            case 'sfixed64':
                type = 'number | string | Long';
                break;
            case 'bool':
                type = 'boolean';
                break;
            case 'string':
                type = 'string';
                break;
            case 'bytes':
                type = 'Buffer | Uint8Array | string';
                break;
            default:
                if (field.resolvedType === null) {
                    throw new Error('Found field with no usable type');
                }
                const typeInterfaceName = getTypeInterfaceName(field.resolvedType);
                if (field.resolvedType instanceof Protobuf.Type) {
                    type = typeInterfaceName;
                }
                else {
                    type = `${typeInterfaceName} | keyof typeof ${typeInterfaceName}`;
                }
        }
        if (options.includeComments) {
            formatComment(formatter, field.comment);
        }
        formatter.writeLine(`'${field.name}'?: (${type})${repeatedString};`);
    }
    for (const oneof of messageType.oneofsArray) {
        const typeString = oneof.fieldsArray.map(field => `"${field.name}"`).join('|');
        if (options.includeComments) {
            formatComment(formatter, oneof.comment);
        }
        formatter.writeLine(`'${oneof.name}'?: ${typeString};`);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateRestrictedMessageInterface(formatter, messageType, options, nameOverride) {
    if (options.includeComments) {
        formatComment(formatter, messageType.comment);
    }
    if (messageType.fullName === '.google.protobuf.Any' && options.json) {
        /* This describes the behavior of the Protobuf.js Any wrapper toObject
         * replacement function */
        formatter.writeLine('export type Any__Output = AnyExtension | {');
        formatter.writeLine('  type_url: string;');
        let type;
        if (options.bytes === Array) {
            type = 'Uint8Array';
        }
        else if (options.bytes === String) {
            type = 'string';
        }
        else {
            type = 'Buffer';
        }
        formatter.writeLine(`  value: ${type};`);
        formatter.writeLine('}');
        return;
    }
    formatter.writeLine(`export interface ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name}__Output {`);
    formatter.indent();
    for (const field of messageType.fieldsArray) {
        const repeatedString = field.repeated ? '[]' : '';
        let fieldGuaranteed = options.defaults || (field.repeated && options.arrays);
        let type;
        switch (field.type) {
            case 'double':
            case 'float':
                if (options.json) {
                    type = 'number | string';
                }
                else {
                    type = 'number';
                }
                break;
            case 'int32':
            case 'uint32':
            case 'sint32':
            case 'fixed32':
            case 'sfixed32':
                type = 'number';
                break;
            case 'int64':
            case 'uint64':
            case 'sint64':
            case 'fixed64':
            case 'sfixed64':
                if (options.longs === Number) {
                    type = 'number';
                }
                else if (options.longs === String) {
                    type = 'string';
                }
                else {
                    type = 'Long';
                }
                break;
            case 'bool':
                type = 'boolean';
                break;
            case 'string':
                type = 'string';
                break;
            case 'bytes':
                if (options.bytes === Array) {
                    type = 'Uint8Array';
                }
                else if (options.bytes === String) {
                    type = 'string';
                }
                else {
                    type = 'Buffer';
                }
                break;
            default:
                if (field.resolvedType === null) {
                    throw new Error('Found field with no usable type');
                }
                const typeInterfaceName = getTypeInterfaceName(field.resolvedType);
                if (field.resolvedType instanceof Protobuf.Type) {
                    fieldGuaranteed = fieldGuaranteed || options.objects;
                    type = typeInterfaceName + '__Output';
                }
                else {
                    if (options.enums == String) {
                        type = `keyof typeof ${typeInterfaceName}`;
                    }
                    else {
                        type = typeInterfaceName;
                    }
                }
        }
        if (field.partOf) {
            fieldGuaranteed = false;
        }
        const optionalString = fieldGuaranteed ? '' : '?';
        if (options.includeComments) {
            formatComment(formatter, field.comment);
        }
        formatter.writeLine(`'${field.name}'${optionalString}: (${type})${repeatedString};`);
    }
    if (options.oneofs) {
        for (const oneof of messageType.oneofsArray) {
            const typeString = oneof.fieldsArray.map(field => `"${field.name}"`).join('|');
            if (options.includeComments) {
                formatComment(formatter, oneof.comment);
            }
            formatter.writeLine(`'${oneof.name}': ${typeString};`);
        }
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateMessageInterfaces(formatter, messageType, options) {
    let usesLong = false;
    let seenDeps = new Set();
    const childTypes = getChildMessagesAndEnums(messageType);
    formatter.writeLine(`// Original file: ${messageType.filename}`);
    formatter.writeLine('');
    messageType.fieldsArray.sort((fieldA, fieldB) => fieldA.id - fieldB.id);
    for (const field of messageType.fieldsArray) {
        if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) {
            const dependency = field.resolvedType;
            if (seenDeps.has(dependency.fullName)) {
                continue;
            }
            seenDeps.add(dependency.fullName);
            formatter.writeLine(getImportLine(dependency, messageType));
        }
        if (field.type.indexOf('64') >= 0) {
            usesLong = true;
        }
    }
    for (const childType of childTypes) {
        if (childType instanceof Protobuf.Type) {
            for (const field of childType.fieldsArray) {
                if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) {
                    const dependency = field.resolvedType;
                    if (seenDeps.has(dependency.fullName)) {
                        continue;
                    }
                    seenDeps.add(dependency.fullName);
                    formatter.writeLine(getImportLine(dependency, messageType));
                }
                if (field.type.indexOf('64') >= 0) {
                    usesLong = true;
                }
            }
        }
    }
    if (usesLong) {
        formatter.writeLine("import { Long } from '@grpc/proto-loader';");
    }
    if (messageType.fullName === '.google.protobuf.Any') {
        formatter.writeLine("import { AnyExtension } from '@grpc/proto-loader';");
    }
    formatter.writeLine('');
    for (const childType of childTypes) {
        const nameOverride = getTypeInterfaceName(childType);
        if (childType instanceof Protobuf.Type) {
            generatePermissiveMessageInterface(formatter, childType, options, nameOverride);
            formatter.writeLine('');
            generateRestrictedMessageInterface(formatter, childType, options, nameOverride);
        }
        else {
            generateEnumInterface(formatter, childType, options, nameOverride);
        }
        formatter.writeLine('');
    }
    generatePermissiveMessageInterface(formatter, messageType, options);
    formatter.writeLine('');
    generateRestrictedMessageInterface(formatter, messageType, options);
}
function generateEnumInterface(formatter, enumType, options, nameOverride) {
    formatter.writeLine(`// Original file: ${enumType.filename}`);
    formatter.writeLine('');
    if (options.includeComments) {
        formatComment(formatter, enumType.comment);
    }
    formatter.writeLine(`export enum ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : enumType.name} {`);
    formatter.indent();
    for (const key of Object.keys(enumType.values)) {
        if (options.includeComments) {
            formatComment(formatter, enumType.comments[key]);
        }
        formatter.writeLine(`${key} = ${enumType.values[key]},`);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateMessageAndEnumImports(formatter, namespace) {
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof Protobuf.Type || nested instanceof Protobuf.Enum) {
            formatter.writeLine(getImportLine(nested));
        }
        else if (isNamespaceBase(nested)) {
            generateMessageAndEnumImports(formatter, nested);
        }
    }
}
function generateMessageAndEnumExports(formatter, namespace, options, nameOverride) {
    formatter.writeLine(`export namespace ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : namespace.name} {`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof Protobuf.Enum || nested instanceof Protobuf.Type) {
            if (options.includeComments) {
                formatComment(formatter, nested.comment);
            }
            formatter.writeLine(`export type ${nested.name} = ${getTypeInterfaceName(nested)};`);
            if (nested instanceof Protobuf.Type) {
                if (options.includeComments) {
                    formatComment(formatter, nested.comment);
                }
                formatter.writeLine(`export type ${nested.name}__Output = ${getTypeInterfaceName(nested)}__Output;`);
            }
        }
        else if (isNamespaceBase(nested)) {
            generateMessageAndEnumExports(formatter, nested, options);
        }
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceClientInterface(formatter, serviceType, options) {
    if (options.includeComments) {
        formatComment(formatter, serviceType.comment);
    }
    formatter.writeLine(`export interface ${serviceType.name}Client extends grpc.Client {`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) {
        const method = serviceType.methods[methodName];
        for (const name of [methodName, camelCase(methodName)]) {
            if (options.includeComments) {
                formatComment(formatter, method.comment);
            }
            const requestType = 'messages.' + stripLeadingPeriod(method.resolvedRequestType.fullName);
            const responseType = 'messages.' + stripLeadingPeriod(method.resolvedResponseType.fullName) + '__Output';
            const callbackType = `(error?: grpc.ServiceError, result?: ${responseType}) => void`;
            if (method.requestStream) {
                if (method.responseStream) {
                    // Bidi streaming
                    const callType = `grpc.ClientDuplexStream<${requestType}, ${responseType}>`;
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, options?: grpc.CallOptions): ${callType};`);
                    formatter.writeLine(`${name}(options?: grpc.CallOptions): ${callType};`);
                }
                else {
                    // Client streaming
                    const callType = `grpc.ClientWritableStream<${responseType}>`;
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                }
            }
            else {
                if (method.responseStream) {
                    // Server streaming
                    const callType = `grpc.ClientReadableStream<${responseType}>`;
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, options?: grpc.CallOptions): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, options?: grpc.CallOptions): ${callType};`);
                }
                else {
                    // Unary
                    const callType = 'grpc.ClientUnaryCall';
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                }
            }
        }
        formatter.writeLine('');
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateAllServiceClientInterfaces(formatter, namespace, options, nameOverride) {
    formatter.writeLine(`export namespace ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : namespace.name} {`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof Protobuf.Service) {
            generateServiceClientInterface(formatter, nested, options);
        }
        else if (isNamespaceBase(nested)) {
            generateAllServiceClientInterfaces(formatter, nested, options);
        }
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateSingleLoadedDefinitionType(formatter, nested, options) {
    if (nested instanceof Protobuf.Service) {
        if (options.includeComments) {
            formatComment(formatter, nested.comment);
        }
        formatter.writeLine(`${nested.name}: SubtypeConstructor<typeof grpc.Client, ClientInterfaces.${stripLeadingPeriod(nested.fullName)}Client> & { service: ServiceDefinition }`);
    }
    else if (nested instanceof Protobuf.Enum) {
        formatter.writeLine(`${nested.name}: EnumTypeDefinition`);
    }
    else if (nested instanceof Protobuf.Type) {
        formatter.writeLine(`${nested.name}: MessageTypeDefinition`);
    }
    else if (isNamespaceBase(nested)) {
        generateLoadedDefinitionTypes(formatter, nested, options);
    }
}
function generateLoadedDefinitionTypes(formatter, namespace, options) {
    formatter.writeLine(`${namespace.name}: {`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) {
        generateSingleLoadedDefinitionType(formatter, nested, options);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceHandlerInterface(formatter, serviceType, options) {
    if (options.includeComments) {
        formatComment(formatter, serviceType.comment);
    }
    formatter.writeLine(`export interface ${serviceType.name} {`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) {
        const method = serviceType.methods[methodName];
        if (options.includeComments) {
            formatComment(formatter, method.comment);
        }
        const requestType = 'messages.' + stripLeadingPeriod(method.resolvedRequestType.fullName) + '__Output';
        const responseType = 'messages.' + stripLeadingPeriod(method.resolvedResponseType.fullName);
        if (method.requestStream) {
            if (method.responseStream) {
                // Bidi streaming
                formatter.writeLine(`${methodName}(call: grpc.ServerDuplexStream<${requestType}, ${responseType}>): void;`);
            }
            else {
                // Client streaming
                formatter.writeLine(`${methodName}(call: grpc.ServerReadableStream<${requestType}>, callback: grpc.sendUnaryData<${responseType}>): void;`);
            }
        }
        else {
            if (method.responseStream) {
                // Server streaming
                formatter.writeLine(`${methodName}(call: grpc.ServerWritableStream<${requestType}, ${responseType}>): void;`);
            }
            else {
                // Unary
                formatter.writeLine(`${methodName}(call: grpc.ServerUnaryCall<${requestType}, ${responseType}>, callback: grpc.sendUnaryData<${responseType}>): void;`);
            }
        }
        formatter.writeLine('');
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateAllServiceHandlerInterfaces(formatter, namespace, options, nameOverride) {
    formatter.writeLine(`export namespace ${nameOverride !== null && nameOverride !== void 0 ? nameOverride : namespace.name} {`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof Protobuf.Service) {
            generateServiceHandlerInterface(formatter, nested, options);
        }
        else if (isNamespaceBase(nested)) {
            generateAllServiceHandlerInterfaces(formatter, nested, options);
        }
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateRootFile(formatter, root, options) {
    formatter.writeLine(`import * as grpc from '${options.grpcLib}';`);
    formatter.writeLine("import { ServiceDefinition, EnumTypeDefinition, MessageTypeDefinition } from '@grpc/proto-loader';");
    formatter.writeLine('');
    generateMessageAndEnumImports(formatter, root);
    formatter.writeLine('');
    generateMessageAndEnumExports(formatter, root, options, 'messages');
    formatter.writeLine('');
    generateAllServiceClientInterfaces(formatter, root, options, 'ClientInterfaces');
    formatter.writeLine('');
    formatter.writeLine('type ConstructorArguments<Constructor> = Constructor extends new (...args: infer Args) => any ? Args: never;');
    formatter.writeLine('type SubtypeConstructor<Constructor, Subtype> = {');
    formatter.writeLine('  new(...args: ConstructorArguments<Constructor>): Subtype;');
    formatter.writeLine('}');
    formatter.writeLine('');
    formatter.writeLine('export interface ProtoGrpcType {');
    formatter.indent();
    for (const nested of root.nestedArray) {
        generateSingleLoadedDefinitionType(formatter, nested, options);
    }
    formatter.unindent();
    formatter.writeLine('}');
    formatter.writeLine('');
    generateAllServiceHandlerInterfaces(formatter, root, options, 'ServiceHandlers');
}
async function writeFile(filename, contents) {
    await fs.promises.mkdir(path.dirname(filename), { recursive: true });
    return fs.promises.writeFile(filename, contents);
}
function generateFilesForNamespace(namespace, options) {
    const filePromises = [];
    for (const nested of namespace.nestedArray) {
        const fileFormatter = new TextFormatter();
        if (nested instanceof Protobuf.Type) {
            generateMessageInterfaces(fileFormatter, nested, options);
            if (options.verbose) {
                console.log(`Writing ${options.outDir}/${getPath(nested)} from file ${nested.filename}`);
            }
            filePromises.push(writeFile(`${options.outDir}/${getPath(nested)}`, fileFormatter.getFullText()));
        }
        else if (nested instanceof Protobuf.Enum) {
            generateEnumInterface(fileFormatter, nested, options);
            if (options.verbose) {
                console.log(`Writing ${options.outDir}/${getPath(nested)} from file ${nested.filename}`);
            }
            filePromises.push(writeFile(`${options.outDir}/${getPath(nested)}`, fileFormatter.getFullText()));
        }
        else if (isNamespaceBase(nested)) {
            filePromises.push(...generateFilesForNamespace(nested, options));
        }
    }
    return filePromises;
}
function writeFilesForRoot(root, masterFileName, options) {
    const filePromises = [];
    const masterFileFormatter = new TextFormatter();
    generateRootFile(masterFileFormatter, root, options);
    if (options.verbose) {
        console.log(`Writing ${options.outDir}/${masterFileName}`);
    }
    filePromises.push(writeFile(`${options.outDir}/${masterFileName}`, masterFileFormatter.getFullText()));
    filePromises.push(...generateFilesForNamespace(root, options));
    return filePromises;
}
async function writeAllFiles(protoFiles, options) {
    await fs.promises.mkdir(options.outDir, { recursive: true });
    for (const filename of protoFiles) {
        const loadedRoot = await util_1.loadProtosWithOptions(filename, options);
        writeFilesForRoot(loadedRoot, path.basename(filename).replace('.proto', '.ts'), options);
    }
}
function runScript() {
    const argv = yargs
        .string(['includeDirs', 'grpcLib'])
        .normalize(['includeDirs', 'outDir'])
        .array('includeDirs')
        .boolean(['keepCase', 'defaults', 'arrays', 'objects', 'oneofs', 'json', 'verbose', 'generateComments'])
        //    .choices('longs', ['String', 'Number'])
        //    .choices('enums', ['String'])
        //    .choices('bytes', ['Array', 'String'])
        .string(['longs', 'enums', 'bytes'])
        .middleware(argv => {
        if (argv.longs) {
            switch (argv.longs) {
                case 'String': argv.longsArg = String;
            }
        }
    })
        .coerce('longs', value => {
        switch (value) {
            case 'String': return String;
            case 'Number': return Number;
            default: return undefined;
        }
    }).coerce('enums', value => {
        if (value === 'String') {
            return String;
        }
        else {
            return undefined;
        }
    }).coerce('bytes', value => {
        switch (value) {
            case 'Array': return Array;
            case 'String': return String;
            default: return undefined;
        }
    }).alias({
        includeDirs: 'I',
        outDir: 'O',
        verbose: 'v'
    }).describe({
        keepCase: 'Preserve the case of field names',
        longs: 'The type that should be used to output 64 bit integer values. Can be String, Number',
        enums: 'The type that should be used to output enum fields. Can be String',
        bytes: 'The type that should be used to output bytes fields. Can be String, Array',
        defaults: 'Output default values for omitted fields',
        arrays: 'Output default values for omitted repeated fields even if --defaults is not set',
        objects: 'Output default values for omitted message fields even if --defaults is not set',
        oneofs: 'Output virtual oneof fields set to the present field\'s name',
        json: 'Represent Infinity and NaN as strings in float fields. Also decode google.protobuf.Any automatically',
        includeDirs: 'Directories to search for included files',
        outDir: 'Directory in which to output files',
        grpcLib: 'The gRPC implementation library that these types will be used with'
    }).demandOption(['outDir', 'grpcLib'])
        .demand(1)
        .usage('$0 [options] filenames...')
        .epilogue('WARNING: This tool is in alpha. The CLI and generated code are subject to change')
        .argv;
    if (argv.verbose) {
        console.log('Parsed arguments:', argv);
    }
    util_1.addCommonProtos();
    writeAllFiles(argv._, Object.assign(Object.assign({}, argv), { alternateCommentMode: true })).then(() => {
        if (argv.verbose) {
            console.log('Success');
        }
    }, (error) => {
        throw error;
    });
}
if (require.main === module) {
    runScript();
}
//# sourceMappingURL=proto-loader-gen-types.js.map